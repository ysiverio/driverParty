# Persistencia de Viajes en Curso

## üéØ **Objetivo**
Implementar un sistema de persistencia que permita a usuarios y conductores recuperar autom√°ticamente su viaje en curso cuando actualicen el navegador o cierren y vuelvan a abrir la aplicaci√≥n.

## üîß **Funcionalidades Implementadas**

### **1. Almacenamiento Local**
- **localStorage**: Persistencia entre sesiones del navegador
- **Claves √∫nicas**: 
  - Usuario: `driverParty_user_trip_state`
  - Driver: `driverParty_driver_trip_state`

### **2. Estados Persistidos**

#### **Usuario (`user/app.js`)**
```javascript
const tripState = {
    currentTripId,           // ID del viaje actual
    currentTripRequestId,    // ID de la solicitud de viaje
    currentTripDriverId,     // ID del conductor asignado
    navigationMode,          // Modo de navegaci√≥n activo
    timestamp: Date.now()    // Timestamp para validaci√≥n
};
```

#### **Driver (`driver/app.js`)**
```javascript
const tripState = {
    activeTripId,           // ID del viaje activo
    navigationMode,         // Modo de navegaci√≥n activo
    timestamp: Date.now()   // Timestamp para validaci√≥n
};
```

### **3. Funciones de Persistencia**

#### **Guardar Estado**
```javascript
function saveTripState() {
    const tripState = {
        // ... datos del estado
        timestamp: Date.now()
    };
    
    try {
        localStorage.setItem(TRIP_STORAGE_KEY, JSON.stringify(tripState));
        console.log('Estado del viaje guardado:', tripState);
    } catch (error) {
        console.error('Error guardando estado del viaje:', error);
    }
}
```

#### **Cargar Estado**
```javascript
function loadTripState() {
    try {
        const savedState = localStorage.getItem(TRIP_STORAGE_KEY);
        if (savedState) {
            const tripState = JSON.parse(savedState);
            
            // Verificar si el estado no es muy antiguo (m√°ximo 24 horas)
            const isRecent = (Date.now() - tripState.timestamp) < (24 * 60 * 60 * 1000);
            
            if (isRecent) {
                // Restaurar variables de estado
                return true;
            } else {
                clearTripState();
            }
        }
    } catch (error) {
        console.error('Error cargando estado del viaje:', error);
        clearTripState();
    }
    return false;
}
```

#### **Limpiar Estado**
```javascript
function clearTripState() {
    try {
        localStorage.removeItem(TRIP_STORAGE_KEY);
        console.log('Estado del viaje limpiado');
    } catch (error) {
        console.error('Error limpiando estado del viaje:', error);
    }
}
```

### **4. Verificaci√≥n y Restauraci√≥n**

#### **Verificaci√≥n Autom√°tica**
```javascript
async function checkAndRestoreActiveTrip() {
    if (!currentUser) return;
    
    const hasActiveTrip = loadTripState();
    if (!hasActiveTrip) return;
    
    // Verificar si el viaje a√∫n existe en Firestore
    if (currentTripId) {
        const tripDoc = await getDoc(doc(db, "trips", currentTripId));
        if (tripDoc.exists()) {
            const tripData = tripDoc.data();
            
            // Si el viaje no est√° completado o cancelado, restaurarlo
            if (tripData.status !== 'completed' && tripData.status !== 'cancelled') {
                await restoreActiveTrip(tripData);
                return;
            }
        }
    }
    
    // Verificar solicitud de viaje activa
    if (currentTripRequestId) {
        const requestDoc = await getDoc(doc(db, "tripRequests", currentTripRequestId));
        if (requestDoc.exists()) {
            const requestData = requestDoc.data();
            
            if (requestData.status !== 'completed' && requestData.status !== 'cancelled' && requestData.status !== 'expired') {
                await restoreActiveTripRequest(requestData);
                return;
            }
        }
    }
    
    // Si no hay viaje v√°lido, limpiar estado
    clearTripState();
    resetTripState();
}
```

### **5. Restauraci√≥n de Estados**

#### **Restaurar Viaje Activo (Usuario)**
```javascript
async function restoreActiveTrip(tripData) {
    try {
        // Restaurar UI del viaje
        tripPanel.style.display = 'block';
        requestPanel.style.display = 'none';
        
        // Actualizar UI con datos del viaje
        updateTripUI(tripData);
        
        // Restaurar informaci√≥n del conductor
        if (tripData.driverInfo && !hasShownDriverInfo) {
            displayDriverInfo(tripData.driverInfo);
        }
        
        // Restaurar ruta y marcadores
        if (tripData.routePolyline) {
            drawRoute(tripData.routePolyline);
        }
        if (tripData.driverLocation) {
            updateDriverMarker(tripData.driverLocation);
        }
        
        // Activar modo navegaci√≥n si es necesario
        if (tripData.status === 'in_progress' && !navigationMode) {
            activateNavigationMode();
        }
        
        // Reconectar listener del viaje
        listenToTripUpdates(currentTripId);
        
        showNotificationToast('Viaje en curso restaurado');
    } catch (error) {
        console.error('Error restaurando viaje:', error);
        clearTripState();
        resetTripState();
    }
}
```

#### **Restaurar Solicitud de Viaje (Usuario)**
```javascript
async function restoreActiveTripRequest(requestData) {
    try {
        // Restaurar UI de la solicitud
        requestPanel.style.display = 'none';
        tripInfoContainer.style.display = 'block';
        
        // Actualizar estado seg√∫n el status
        if (requestData.status === 'accepted') {
            tripStatusHeading.textContent = 'Conductor Encontrado';
            tripStatusDetails.textContent = 'Por favor, confirma los detalles y el pago para comenzar.';
            
            // Mostrar modal de confirmaci√≥n de pago
            const driverRef = doc(db, "drivers", requestData.driverId);
            const driverDoc = await getDoc(driverRef);
            const driverData = driverDoc.exists() ? driverDoc.data() : {};
            showPaymentConfirmationModal(requestData, driverData);
        } else {
            tripStatusHeading.textContent = 'Buscando Conductor';
            tripStatusDetails.textContent = 'Estamos buscando un conductor disponible...';
        }
        
        // Reconectar listener de la solicitud
        listenToTripRequestUpdates(currentTripRequestId);
        
        showNotificationToast('Solicitud de viaje restaurada');
    } catch (error) {
        console.error('Error restaurando solicitud de viaje:', error);
        clearTripState();
        resetTripState();
    }
}
```

#### **Restaurar Viaje Activo (Driver)**
```javascript
async function restoreActiveTrip(tripData) {
    try {
        // Restaurar UI del viaje
        requestsPanel.style.display = 'none';
        tripPanel.style.display = 'block';
        tripClientName.textContent = tripData.userName;
        
        // Restaurar marcador del usuario
        const userLocation = tripData.originCoords || tripData.userLocation;
        if (userLocation) {
            userMarker = createCustomMarker(userLocation, map, tripData.userName, '#4285f4');
        }
        
        // Obtener ubicaci√≥n actual y calcular ruta
        navigator.geolocation.getCurrentPosition((pos) => {
            const location = { lat: pos.coords.latitude, lng: pos.coords.longitude };
            calculateAndDisplayRoute(location, userLocation);
            startSharingLocation(location);
        }, (err) => console.error("Geolocation error:", err));
        
        // Activar modo navegaci√≥n si es necesario
        if (tripData.status === 'in_progress' && !navigationMode) {
            activateNavigationMode(userLocation);
        }
        
        // Escuchar rechazo del usuario
        listenForTripRejection(activeTripId);
        
        showNotificationToast('Viaje en curso restaurado');
    } catch (error) {
        console.error('Error restaurando viaje:', error);
        clearTripState();
        resetTripState();
    }
}
```

## üîÑ **Puntos de Guardado Autom√°tico**

### **Usuario**
- ‚úÖ **Solicitud de viaje**: Al crear una nueva solicitud
- ‚úÖ **Confirmaci√≥n de pago**: Al confirmar el pago y crear el viaje
- ‚úÖ **Modo navegaci√≥n**: Al activar el modo de navegaci√≥n
- ‚úÖ **Limpieza**: Al resetear el estado o cerrar sesi√≥n

### **Driver**
- ‚úÖ **Aceptar viaje**: Al aceptar una solicitud de viaje
- ‚úÖ **Modo navegaci√≥n**: Al activar el modo de navegaci√≥n
- ‚úÖ **Limpieza**: Al resetear el estado o cerrar sesi√≥n

## üõ°Ô∏è **Validaciones y Seguridad**

### **1. Validaci√≥n de Tiempo**
- **L√≠mite**: 24 horas m√°ximo
- **Prop√≥sito**: Evitar estados obsoletos
- **Acci√≥n**: Limpiar autom√°ticamente estados antiguos

### **2. Verificaci√≥n en Firestore**
- **Validaci√≥n**: Verificar que el viaje/solicitud a√∫n existe
- **Estados v√°lidos**: Solo restaurar viajes no completados/cancelados
- **Fallback**: Limpiar estado si no es v√°lido

### **3. Manejo de Errores**
- **Try-catch**: En todas las operaciones de localStorage
- **Logging**: Informaci√≥n detallada para debugging
- **Recuperaci√≥n**: Limpiar estado en caso de error

## üì± **Experiencia del Usuario**

### **1. Recuperaci√≥n Autom√°tica**
- **Momento**: Al iniciar sesi√≥n (2 segundos despu√©s)
- **Notificaci√≥n**: "Viaje en curso restaurado"
- **Estado**: UI completamente restaurada

### **2. Transparencia**
- **Sin intervenci√≥n**: No requiere acci√≥n del usuario
- **Continuidad**: El viaje contin√∫a donde se qued√≥
- **Sincronizaci√≥n**: Estado actualizado con Firestore

### **3. Robustez**
- **Fallbacks**: M√∫ltiples verificaciones
- **Limpieza**: Estados inv√°lidos se eliminan autom√°ticamente
- **Logging**: Informaci√≥n detallada para debugging

## üîß **Configuraci√≥n**

### **Claves de Almacenamiento**
```javascript
// Usuario
const TRIP_STORAGE_KEY = 'driverParty_user_trip_state';

// Driver
const TRIP_STORAGE_KEY = 'driverParty_driver_trip_state';
```

### **Tiempo de Validaci√≥n**
```javascript
// 24 horas en milisegundos
const MAX_AGE = 24 * 60 * 60 * 1000;
```

### **Delay de Verificaci√≥n**
```javascript
// 2 segundos para permitir inicializaci√≥n del mapa
setTimeout(async () => {
    await checkAndRestoreActiveTrip();
}, 2000);
```

## üìä **Casos de Uso Cubiertos**

### **1. Usuario Actualiza Navegador**
1. Usuario tiene viaje en curso ‚úÖ
2. Actualiza navegador ‚úÖ
3. Inicia sesi√≥n ‚úÖ
4. Sistema detecta viaje activo ‚úÖ
5. Restaura estado completo ‚úÖ
6. Contin√∫a el viaje ‚úÖ

### **2. Driver Actualiza Navegador**
1. Driver tiene viaje activo ‚úÖ
2. Actualiza navegador ‚úÖ
3. Inicia sesi√≥n ‚úÖ
4. Sistema detecta viaje activo ‚úÖ
5. Restaura estado completo ‚úÖ
6. Contin√∫a el viaje ‚úÖ

### **3. Solicitud Pendiente**
1. Usuario solicita viaje ‚úÖ
2. Cierra navegador ‚úÖ
3. Vuelve a abrir ‚úÖ
4. Sistema restaura solicitud ‚úÖ
5. Contin√∫a buscando conductor ‚úÖ

### **4. Viaje Completado**
1. Viaje termina ‚úÖ
2. Estado se limpia autom√°ticamente ‚úÖ
3. No se restaura en pr√≥xima sesi√≥n ‚úÖ

## üéØ **Beneficios**

### **1. Experiencia de Usuario**
- ‚úÖ **Continuidad**: No se pierden viajes por actualizar
- ‚úÖ **Conveniencia**: Recuperaci√≥n autom√°tica
- ‚úÖ **Confianza**: Sistema robusto y confiable

### **2. Funcionalidad**
- ‚úÖ **Persistencia**: Estados se mantienen entre sesiones
- ‚úÖ **Sincronizaci√≥n**: Estado actualizado con base de datos
- ‚úÖ **Validaci√≥n**: Solo estados v√°lidos se restauran

### **3. Robustez**
- ‚úÖ **Manejo de errores**: Try-catch en todas las operaciones
- ‚úÖ **Limpieza autom√°tica**: Estados obsoletos se eliminan
- ‚úÖ **Logging**: Informaci√≥n detallada para debugging

## üìù **Archivos Modificados**

### **1. `user/app.js`**
- ‚úÖ Funciones de persistencia (`saveTripState`, `loadTripState`, `clearTripState`)
- ‚úÖ Verificaci√≥n y restauraci√≥n (`checkAndRestoreActiveTrip`, `restoreActiveTrip`, `restoreActiveTripRequest`)
- ‚úÖ Puntos de guardado autom√°tico
- ‚úÖ Integraci√≥n con autenticaci√≥n

### **2. `driver/app.js`**
- ‚úÖ Funciones de persistencia (`saveTripState`, `loadTripState`, `clearTripState`)
- ‚úÖ Verificaci√≥n y restauraci√≥n (`checkAndRestoreActiveTrip`, `restoreActiveTrip`)
- ‚úÖ Puntos de guardado autom√°tico
- ‚úÖ Integraci√≥n con autenticaci√≥n

## üöÄ **Estado Actual**

‚úÖ **Sistema completo**: Persistencia implementada para usuario y driver
‚úÖ **Recuperaci√≥n autom√°tica**: Estados se restauran al iniciar sesi√≥n
‚úÖ **Validaci√≥n robusta**: Solo estados v√°lidos se restauran
‚úÖ **Manejo de errores**: Try-catch en todas las operaciones
‚úÖ **Limpieza autom√°tica**: Estados obsoletos se eliminan
‚úÖ **Experiencia fluida**: Sin intervenci√≥n del usuario

## üîÆ **Pr√≥ximos Pasos**

1. **Testing**: Probar recuperaci√≥n en diferentes escenarios
2. **Monitoreo**: Observar logs para confirmar funcionamiento
3. **Optimizaci√≥n**: Ajustar tiempos de validaci√≥n si es necesario
4. **Feedback**: Recopilar feedback de usuarios sobre la experiencia
